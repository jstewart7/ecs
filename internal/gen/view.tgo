package ecs

// Warning: This is an autogenerated file. Do not modify!!

{{range $i, $element := .Views}}

// --------------------------------------------------------------------------------
// - View {{len $element}}
// --------------------------------------------------------------------------------

// Represents a view of data in a specific world. Provides access to the components specified in the generic block
type View{{len $element}}[{{join $element ","}} any] struct {
	world *World
	filter filterList
	{{range $ii, $arg := $element}}
	storage{{$arg}} *componentSliceStorage[{{$arg}}]{{end}}
}

// Creates a View for the specified world with the specified component filters.
func Query{{len $element}}[{{join $element ","}} any](world *World, filters ...Filter) *View{{len $element}}[{{join $element ","}}] {
{{range $ii, $arg := $element}}
	storage{{$arg}} := getStorage[{{$arg}}](world.engine){{end}}

{{range $ii, $arg := $element}}
	var {{$arg}}{{$arg}} {{$arg}}{{end}}

	comps := []componentId{
{{range $ii, $arg := $element}}
		name({{$arg}}{{$arg}}),{{end}}

	}
	filterList := newFilterList(comps, filters...)
	filterList.regenerate(world)

	v := &View{{len $element}}[{{join $element ","}}]{
		world: world,
		filter: filterList,
{{range $ii, $arg := $element}}
		storage{{$arg}}: storage{{$arg}},{{end}}
	}
	return v
}

// Reads a pointer to the underlying component at the specified id.
// Read will return even if the specified id doesn't match the filter list
// Read will return the value if it exists, else returns nil.
// If you execute any ecs.Write(...) or ecs.Delete(...) this pointer may become invalid.
func (v *View{{len $element}}[{{join $element ","}}]) Read(id Id) (*{{join $element ",*"}}) {
	if id == InvalidEntity {
		return {{with len $element}}{{nils .}}{{end}}
	}

	archId, ok := v.world.arch[id]
	if !ok {
		return {{with len $element}}{{nils .}}{{end}}
	}
	lookup, ok := v.world.engine.lookup[archId]
	if !ok {
		panic("LookupList is missing!")
	}
	index, ok := lookup.index[id]
	if !ok {
		return {{with len $element}}{{nils .}}{{end}}
	}

{{range $ii, $arg := $element}}
	var ret{{$arg}} *{{$arg}}{{end}}

	{{range $ii, $arg := $element}}	slice{{$arg}}, ok := v.storage{{$arg}}.slice[archId]
	if ok {
		ret{{$arg}} = &slice{{$arg}}.comp[index]
	}
	{{end}}

	return {{retlist $element}}
}

// Maps the lambda function across every entity which matched the specified filters.
func (v *View{{len $element}}[{{join $element ","}}]) MapId(lambda func(id Id, {{lambdaArgs $element}})) {
	v.filter.regenerate(v.world)

	{{range $ii, $arg := $element}}
	var slice{{$arg}} *componentSlice[{{$arg}}]
	var comp{{$arg}} []{{$arg}}
	var ret{{$arg}} *{{$arg}}
	{{end}}

	for _, archId := range v.filter.archIds {
		{{range $ii, $arg := $element}}
		slice{{$arg}}, _ = v.storage{{$arg}}.slice[archId]{{end}}

		lookup, ok := v.world.engine.lookup[archId]
		if !ok { panic("LookupList is missing!") }
		ids := lookup.id


		// TODO - this flattened version causes a mild performance hit. But the other one combinatorially explodes. I also cant get BCE to work with it. See option 2 for higher performance.
		{{range $ii, $arg := $element}}
		comp{{$arg}} = nil
		if slice{{$arg}} != nil {
			comp{{$arg}} = slice{{$arg}}.comp
		}{{end}}

		{{range $ii, $arg := $element}}
		ret{{$arg}} = nil{{end}}
		for idx := range ids {
			if ids[idx] == InvalidEntity { continue } // Skip if its a hole
			{{range $ii, $arg := $element}}
			if comp{{$arg}} != nil { ret{{$arg}} = &comp{{$arg}}[idx] }{{end}}
			lambda(ids[idx], {{retlist $element}})
		}

	// 	// Option 2 - This is faster but has a combinatorial explosion problem
	// 	if compA == nil && compB == nil {
	// 		return
	// 	} else if compA != nil && compB == nil {
	// 		if len(ids) != len(compA) {
	// 			panic("ERROR - Bounds don't match")
	// 		}
	// 		for i := range ids {
	// 			if ids[i] == InvalidEntity { continue }
	// 			lambda(ids[i], &compA[i], nil)
	// 		}
	// 	} else if compA == nil && compB != nil {
	// 		if len(ids) != len(compB) {
	// 			panic("ERROR - Bounds don't match")
	// 		}
	// 		for i := range ids {
	// 			if ids[i] == InvalidEntity { continue }
	// 			lambda(ids[i], nil, &compB[i])
	// 		}
	// 	} else if compA != nil && compB != nil {
	// 		if len(ids) != len(compA) || len(ids) != len(compB) {
	// 			panic("ERROR - Bounds don't match")
	// 		}
	// 		for i := range ids {
	// 			if ids[i] == InvalidEntity { continue }
	// 			lambda(ids[i], &compA[i], &compB[i])
	// 		}
	// 	}
	}

		// Original - doesn't handle optional
	// for _, archId := range v.filter.archIds {
	// 	aSlice, ok := v.storageA.slice[archId]
	// 	if !ok { continue }
	// 	bSlice, ok := v.storageB.slice[archId]
	// 	if !ok { continue }

	// 	lookup, ok := v.world.engine.lookup[archId]
	// 	if !ok { panic("LookupList is missing!") }

	// 	ids := lookup.id
	// 	aComp := aSlice.comp
	// 	bComp := bSlice.comp
	// 	if len(ids) != len(aComp) || len(ids) != len(bComp) {
	// 		panic("ERROR - Bounds don't match")
	// 	}
	// 	for i := range ids {
	// 		if ids[i] == InvalidEntity { continue }
	// 		lambda(ids[i], &aComp[i], &bComp[i])
	// 	}
	// }
}

// Deprecated: This API is a tentative alternative way to map
func (v *View{{len $element}}[{{join $element ","}}]) MapSlices(lambda func(id []Id, {{sliceLambdaArgs $element}})) {
	v.filter.regenerate(v.world)

	id := make([][]Id, 0)

	{{range $ii, $arg := $element}}
	sliceList{{$arg}} := make([][]{{$arg}}, 0){{end}}

	for _, archId := range v.filter.archIds {
		{{range $ii, $arg := $element}}
		slice{{$arg}}, ok := v.storage{{$arg}}.slice[archId]
		if !ok { continue }{{end}}

		lookup, ok := v.world.engine.lookup[archId]
		if !ok { panic("LookupList is missing!") }

		id = append(id, lookup.id)
		{{range $ii, $arg := $element}}
		sliceList{{$arg}} = append(sliceList{{$arg}}, slice{{$arg}}.comp){{end}}
	}

	for idx := range id {
		lambda(id[idx],
			{{range $ii, $arg := $element}}sliceList{{$arg}}[idx],{{end}}
		)
	}
}
{{end}}
